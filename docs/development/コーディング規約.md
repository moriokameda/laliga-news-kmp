# Kotlin Multiplatform コーディング規約

## 目次
1. [基本原則](#基本原則)
2. [Kotlin言語規約](#kotlin言語規約)
3. [Kotlin Multiplatform固有規約](#kotlin-multiplatform固有規約)
4. [アーキテクチャ規約](#アーキテクチャ規約)
5. [非同期処理規約](#非同期処理規約)
6. [UI/UX規約](#uiux規約)
7. [依存性注入規約](#依存性注入規約)
8. [テスト規約](#テスト規約)
9. [コメントとドキュメント](#コメントとドキュメント)

## 基本原則

### DRY原則（Don't Repeat Yourself）
すべてのコードは一度だけ書き、再利用可能にする。

#### 実践方法
```kotlin
// ❌ 悪い例：同じロジックを複数箇所に記述
class NewsListViewModel {
    fun loadNews() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            try {
                val articles = repository.getNews()
                _uiState.update { it.copy(isLoading = false, articles = articles) }
            } catch (e: Exception) {
                _uiState.update { it.copy(isLoading = false, error = e.message) }
            }
        }
    }
    
    fun refreshNews() {
        viewModelScope.launch {
            _uiState.update { it.copy(isRefreshing = true) }
            try {
                val articles = repository.getNews()
                _uiState.update { it.copy(isRefreshing = false, articles = articles) }
            } catch (e: Exception) {
                _uiState.update { it.copy(isRefreshing = false, error = e.message) }
            }
        }
    }
}

// ✅ 良い例：共通ロジックを抽出
class NewsListViewModel {
    fun loadNews() = fetchNews(isRefresh = false)
    fun refreshNews() = fetchNews(isRefresh = true)
    
    private fun fetchNews(isRefresh: Boolean) {
        viewModelScope.launch {
            _uiState.update { 
                if (isRefresh) it.copy(isRefreshing = true)
                else it.copy(isLoading = true)
            }
            
            repository.getNews()
                .onSuccess { articles ->
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            isRefreshing = false,
                            articles = articles,
                            error = null
                        )
                    }
                }
                .onFailure { exception ->
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            isRefreshing = false,
                            error = exception.message
                        )
                    }
                }
        }
    }
}
```

### KISS原則（Keep It Simple, Stupid）
シンプルで理解しやすいコードを書く。

```kotlin
// ❌ 悪い例：過度に複雑
fun formatDate(timestamp: Long): String {
    return SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).apply {
        timeZone = TimeZone.getTimeZone("UTC")
    }.format(Date(timestamp)).let { date ->
        date.split("-").let { parts ->
            "${parts[0]}年${parts[1].toInt()}月${parts[2].toInt()}日"
        }
    }
}

// ✅ 良い例：シンプルで明確
fun formatDate(timestamp: Long): String {
    val date = Date(timestamp)
    val formatter = SimpleDateFormat("yyyy年M月d日", Locale.JAPAN)
    return formatter.format(date)
}
```

### 単一責任原則
各クラス・関数は一つの責任のみを持つ。

```kotlin
// ❌ 悪い例：複数の責任を持つクラス
class NewsManager {
    fun fetchNewsFromNetwork(): List<NewsArticle> { }
    fun saveToDatabase(articles: List<NewsArticle>) { }
    fun translateArticle(article: NewsArticle): NewsArticle { }
    fun formatDateForDisplay(date: Date): String { }
}

// ✅ 良い例：責任を分離
class NewsRepository {
    fun getNews(): List<NewsArticle> { }
}

class NewsCache {
    fun save(articles: List<NewsArticle>) { }
}

class TranslationService {
    fun translate(article: NewsArticle): NewsArticle { }
}

class DateFormatter {
    fun format(date: Date): String { }
}
```

## Kotlin言語規約

### 命名規則

#### クラス・インターフェース
- **PascalCase**を使用
- 名詞または名詞句を使用
- 明確で意味のある名前

```kotlin
// ✅ 良い例
class NewsArticle
interface NewsRepository
abstract class BaseViewModel

// ❌ 悪い例
class newsarticle
class NA  // 省略形は避ける
class ProcessNews  // 動詞は避ける
```

#### 関数・プロパティ
- **camelCase**を使用
- 関数は動詞で始める
- プロパティは名詞

```kotlin
// ✅ 良い例
fun loadNews()
fun calculateTotal(items: List<Item>): Double
val newsTitle: String
var isLoading: Boolean

// ❌ 悪い例
fun LoadNews()  // PascalCaseは使わない
fun calc()  // 省略形は避ける
val title_news  // snake_caseは使わない
```

#### 定数
- **UPPER_SNAKE_CASE**を使用
- `const val`または`object`内で定義

```kotlin
// ✅ 良い例
const val MAX_RETRY_COUNT = 3
const val DEFAULT_TIMEOUT_MS = 5000L

object Constants {
    const val API_BASE_URL = "https://api.laliga.com"
    const val CACHE_SIZE_MB = 50
}

// ❌ 悪い例
const val maxRetryCount = 3  // camelCaseは使わない
val MAX_RETRY = 3  // constを付け忘れ
```

#### パッケージ名
- **小文字**のみ使用
- ドット区切り
- 意味のある階層構造

```kotlin
// ✅ 良い例
package com.laliga.news.data.repository
package com.laliga.news.presentation.screen

// ❌ 悪い例
package com.LaLiga.News  // 大文字は使わない
package com.laliga.news_data  // アンダースコアは使わない
```

### Null安全性の活用

```kotlin
// ✅ 良い例：Null安全を活用
fun processArticle(article: NewsArticle?) {
    article?.let { nonNullArticle ->
        // articleがnullでない場合のみ実行
        displayArticle(nonNullArticle)
    }
    
    // エルビス演算子でデフォルト値
    val title = article?.title ?: "タイトルなし"
    
    // 安全呼び出し
    val length = article?.content?.length ?: 0
}

// ❌ 悪い例：明示的なnullチェック
fun processArticle(article: NewsArticle?) {
    if (article != null) {
        displayArticle(article)
    }
    
    val title = if (article != null) article.title else "タイトルなし"
}
```

### 拡張関数の使用ルール

```kotlin
// ✅ 良い例：適切な拡張関数
// 汎用的で再利用可能
fun String.toNewsDate(): Date? {
    return try {
        SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).parse(this)
    } catch (e: Exception) {
        null
    }
}

// NewsArticle固有の機能
fun NewsArticle.getSummary(maxLength: Int = 100): String {
    return if (content.length > maxLength) {
        content.take(maxLength) + "..."
    } else {
        content
    }
}

// ❌ 悪い例：不適切な拡張関数
// あまりに特殊すぎる
fun String.convertToLaLigaNewsFormat(): String { }

// 既存の機能と重複
fun List<NewsArticle>.getSize(): Int = this.size  // sizeプロパティが既にある
```

### スコープ関数の使い分け

```kotlin
// let - null安全な処理、変換
article?.let { nonNullArticle ->
    repository.save(nonNullArticle)
}

// apply - オブジェクトの初期化
val viewModel = NewsListViewModel().apply {
    loadInitialData()
    observeNetworkStatus()
}

// also - 副作用のある処理
articles
    .filter { it.isImportant }
    .also { Logger.log("Important articles: ${it.size}") }
    .map { it.title }

// with - 既存オブジェクトへの複数操作
with(binding) {
    titleText.text = article.title
    contentText.text = article.content
    dateText.text = article.publishedAt
}

// run - letとwithの組み合わせ
val result = article?.run {
    // thisはarticle（non-null）
    translateIfNeeded(this)
} ?: defaultArticle
```

## Kotlin Multiplatform固有規約

### commonMainで実装すべきもの
- ビジネスロジック
- データモデル
- リポジトリインターフェース
- ViewModel
- 共通UI（Compose Multiplatform）

```kotlin
// commonMain/kotlin/data/model/NewsArticle.kt
data class NewsArticle(
    val id: String,
    val title: String,
    val content: String,
    val publishedAt: LocalDateTime,
    val imageUrls: List<String>
)

// commonMain/kotlin/domain/repository/NewsRepository.kt
interface NewsRepository {
    suspend fun getNewsList(): List<NewsArticle>
    suspend fun getNewsDetail(id: String): NewsArticle
}
```

### expect/actualパターンの使用基準

#### 使用すべきケース
- プラットフォーム固有のAPI呼び出し
- ファイルシステムアクセス
- プラットフォーム固有のログ出力

```kotlin
// commonMain
expect object Logger {
    fun log(level: LogLevel, message: String)
}

expect fun getPlatformName(): String

// androidMain
actual object Logger {
    actual fun log(level: LogLevel, message: String) {
        Log.d("LaLigaNews", "[$level] $message")
    }
}

actual fun getPlatformName(): String = "Android"

// iosMain
actual object Logger {
    actual fun log(level: LogLevel, message: String) {
        NSLog("LaLigaNews: [$level] $message")
    }
}

actual fun getPlatformName(): String = "iOS"
```

#### 使用を避けるべきケース
- インターフェースで抽象化可能な場合
- DIで解決可能な場合

```kotlin
// ❌ 悪い例：expect/actualの過度な使用
expect class HttpClient {
    fun get(url: String): String
}

// ✅ 良い例：インターフェースとDI
interface HttpClient {
    suspend fun get(url: String): String
}

// Koinモジュールで実装を注入
val networkModule = module {
    single<HttpClient> { KtorHttpClient() }
}
```

### プラットフォーム固有コードの分離戦略

```kotlin
// commonMain - 共通インターフェース
interface DeviceInfo {
    val platform: String
    val osVersion: String
    val deviceModel: String
}

// androidMain - Android実装
class AndroidDeviceInfo : DeviceInfo {
    override val platform = "Android"
    override val osVersion = Build.VERSION.RELEASE
    override val deviceModel = "${Build.MANUFACTURER} ${Build.MODEL}"
}

// iosMain - iOS実装  
class IOSDeviceInfo : DeviceInfo {
    override val platform = "iOS"
    override val osVersion = UIDevice.currentDevice.systemVersion
    override val deviceModel = UIDevice.currentDevice.model
}
```

## アーキテクチャ規約

### MVVMパターンの実装ルール

```kotlin
// ViewModel - UIロジックとビジネスロジックの橋渡し
class NewsListViewModel(
    private val repository: NewsRepository
) : ViewModel() {
    // UI状態は単一のStateFlowで管理
    private val _uiState = MutableStateFlow(NewsListUiState())
    val uiState: StateFlow<NewsListUiState> = _uiState.asStateFlow()
    
    // UIイベントはpublic関数で受け取る
    fun onRefresh() {
        loadNews(isRefresh = true)
    }
    
    fun onArticleClick(articleId: String) {
        // ナビゲーションイベントを発行
    }
    
    // ビジネスロジックはprivate
    private fun loadNews(isRefresh: Boolean = false) {
        viewModelScope.launch {
            // 実装
        }
    }
}

// View (Compose) - UIの描画のみ
@Composable
fun NewsListScreen(
    viewModel: NewsListViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    // UIの描画ロジックのみ
    when {
        uiState.isLoading -> LoadingView()
        uiState.error != null -> ErrorView(uiState.error)
        else -> NewsList(
            articles = uiState.articles,
            onArticleClick = viewModel::onArticleClick
        )
    }
}
```

### Repository パターンの実装

```kotlin
// インターフェース定義（commonMain）
interface NewsRepository {
    suspend fun getNewsList(): Result<List<NewsArticle>>
    suspend fun getNewsDetail(id: String): Result<NewsArticle>
    suspend fun searchNews(query: String): Result<List<NewsArticle>>
}

// 実装（commonMain）
class NewsRepositoryImpl(
    private val remoteDataSource: NewsRemoteDataSource,
    private val localDataSource: NewsLocalDataSource
) : NewsRepository {
    
    override suspend fun getNewsList(): Result<List<NewsArticle>> {
        return try {
            // キャッシュ優先戦略
            val cachedNews = localDataSource.getNewsList()
            if (cachedNews.isNotEmpty() && !isExpired(cachedNews)) {
                return Result.success(cachedNews)
            }
            
            // リモートから取得
            val remoteNews = remoteDataSource.getNewsList()
            localDataSource.saveNewsList(remoteNews)
            Result.success(remoteNews)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### State管理（StateFlow優先）

```kotlin
// UI状態の定義
data class NewsListUiState(
    val articles: List<NewsArticle> = emptyList(),
    val isLoading: Boolean = false,
    val isRefreshing: Boolean = false,
    val error: String? = null,
    val searchQuery: String = ""
)

// ViewModelでの状態管理
class NewsListViewModel(
    private val repository: NewsRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(NewsListUiState())
    val uiState: StateFlow<NewsListUiState> = _uiState.asStateFlow()
    
    // 状態更新は必ずupdate関数を使用
    private fun updateState(update: NewsListUiState.() -> NewsListUiState) {
        _uiState.update(update)
    }
    
    fun loadNews() {
        viewModelScope.launch {
            updateState { copy(isLoading = true, error = null) }
            
            repository.getNewsList()
                .onSuccess { articles ->
                    updateState { 
                        copy(
                            articles = articles,
                            isLoading = false
                        )
                    }
                }
                .onFailure { exception ->
                    updateState {
                        copy(
                            error = exception.message,
                            isLoading = false
                        )
                    }
                }
        }
    }
}
```

## 非同期処理規約

### Coroutines + Flowの統一使用

```kotlin
// suspend関数 - 単一の結果を返す非同期処理
suspend fun fetchArticle(id: String): NewsArticle {
    return withContext(Dispatchers.IO) {
        // ネットワーク処理
        httpClient.get("/articles/$id")
    }
}

// Flow - 複数の値を時系列で返す非同期処理
fun observeArticles(): Flow<List<NewsArticle>> {
    return flow {
        while (currentCoroutineContext().isActive) {
            emit(fetchLatestArticles())
            delay(30_000) // 30秒ごとに更新
        }
    }
    .flowOn(Dispatchers.IO)
    .catch { e ->
        Logger.log(LogLevel.ERROR, "Failed to observe articles: ${e.message}")
        emit(emptyList())
    }
}
```

### viewModelScopeの活用

```kotlin
class NewsDetailViewModel(
    private val repository: NewsRepository,
    private val articleId: String
) : ViewModel() {
    
    init {
        loadArticle()
    }
    
    private fun loadArticle() {
        // viewModelScopeを使用 - ViewModelの破棄時に自動キャンセル
        viewModelScope.launch {
            repository.getNewsDetail(articleId)
                .onSuccess { article ->
                    _uiState.update { it.copy(article = article) }
                }
        }
    }
    
    // 複数の非同期処理を並列実行
    private fun loadArticleWithRelated() {
        viewModelScope.launch {
            val articleDeferred = async { repository.getNewsDetail(articleId) }
            val relatedDeferred = async { repository.getRelatedArticles(articleId) }
            
            val article = articleDeferred.await()
            val related = relatedDeferred.await()
            
            _uiState.update {
                it.copy(
                    article = article.getOrNull(),
                    relatedArticles = related.getOrNull() ?: emptyList()
                )
            }
        }
    }
}
```

### エラーハンドリングパターン

```kotlin
// Result型を使用した明示的なエラーハンドリング
sealed class NetworkResult<out T> {
    data class Success<T>(val data: T) : NetworkResult<T>()
    data class Error(val exception: Exception) : NetworkResult<Nothing>()
    object Loading : NetworkResult<Nothing>()
}

// リポジトリでの実装
class NewsRepositoryImpl : NewsRepository {
    override suspend fun getNewsList(): NetworkResult<List<NewsArticle>> {
        return try {
            NetworkResult.Loading
            val response = httpClient.get<NewsResponse>("/news")
            NetworkResult.Success(response.articles)
        } catch (e: IOException) {
            NetworkResult.Error(NetworkException("ネットワークエラー", e))
        } catch (e: SerializationException) {
            NetworkResult.Error(DataException("データ解析エラー", e))
        } catch (e: Exception) {
            NetworkResult.Error(UnknownException("不明なエラー", e))
        }
    }
}

// ViewModelでの使用
fun loadNews() {
    viewModelScope.launch {
        repository.getNewsList().collect { result ->
            when (result) {
                is NetworkResult.Loading -> {
                    _uiState.update { it.copy(isLoading = true) }
                }
                is NetworkResult.Success -> {
                    _uiState.update {
                        it.copy(
                            articles = result.data,
                            isLoading = false,
                            error = null
                        )
                    }
                }
                is NetworkResult.Error -> {
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            error = result.exception.userMessage()
                        )
                    }
                }
            }
        }
    }
}
```

### キャンセレーション処理

```kotlin
class NewsSearchViewModel : ViewModel() {
    private var searchJob: Job? = null
    
    fun search(query: String) {
        // 前の検索をキャンセル
        searchJob?.cancel()
        
        searchJob = viewModelScope.launch {
            delay(300) // デバウンス
            
            // キャンセルされていないかチェック
            ensureActive()
            
            repository.searchNews(query)
                .onSuccess { results ->
                    _searchResults.value = results
                }
        }
    }
    
    // 長時間実行される処理での協調的キャンセレーション
    private suspend fun processLargeDataset(articles: List<NewsArticle>) {
        articles.forEachIndexed { index, article ->
            // 定期的にキャンセレーションをチェック
            if (index % 100 == 0) {
                yield() // 他のコルーチンに実行を譲る
            }
            
            processArticle(article)
        }
    }
}
```

## UI/UX規約

### Compose Multiplatform規約

```kotlin
// Composable関数は大文字で開始
@Composable
fun NewsCard(
    article: NewsArticle,
    modifier: Modifier = Modifier, // Modifierは最初のパラメータ（必須引数の後）
    onClick: () -> Unit = {} // コールバックは最後
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        onClick = onClick
    ) {
        // 実装
    }
}

// プレビュー用のComposable
@Preview
@Composable
private fun NewsCardPreview() {
    LaLigaNewsTheme {
        NewsCard(
            article = sampleArticle,
            onClick = {}
        )
    }
}
```

### Modifierの使用ルール

```kotlin
// ✅ 良い例：Modifierチェーンを明確に
@Composable
fun NewsItemCard(
    article: NewsArticle,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()           // サイズ
            .padding(16.dp)            // 外側の余白
            .clip(RoundedCornerShape(8.dp))  // 形状
            .clickable { /* action */ }      // インタラクション
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)  // 内側の余白
        ) {
            // コンテンツ
        }
    }
}

// ❌ 悪い例：Modifierの順序が不適切
Card(
    modifier = modifier
        .clickable { }  // クリック領域が小さくなる
        .padding(16.dp)
        .fillMaxWidth()
)
```

### State Hoisting

```kotlin
// ✅ 良い例：状態を上位に持ち上げる
@Composable
fun NewsListScreen(
    viewModel: NewsListViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    NewsListContent(
        articles = uiState.articles,
        isLoading = uiState.isLoading,
        onRefresh = viewModel::refresh,
        onArticleClick = viewModel::selectArticle
    )
}

// ステートレスなComposable
@Composable
fun NewsListContent(
    articles: List<NewsArticle>,
    isLoading: Boolean,
    onRefresh: () -> Unit,
    onArticleClick: (String) -> Unit
) {
    // UIの描画のみ
}

// ❌ 悪い例：Composable内で状態を管理
@Composable
fun NewsListBadExample() {
    var articles by remember { mutableStateOf(emptyList<NewsArticle>()) }
    LaunchedEffect(Unit) {
        articles = loadArticles() // Composable内でビジネスロジック
    }
}
```

### パフォーマンス最適化

```kotlin
// キー付きアイテムでリコンポジションを最適化
@Composable
fun NewsList(articles: List<NewsArticle>) {
    LazyColumn {
        items(
            items = articles,
            key = { article -> article.id } // 安定したキー
        ) { article ->
            NewsCard(article = article)
        }
    }
}

// 高コストな計算はrememberで記憶
@Composable
fun ExpensiveComponent(data: List<NewsArticle>) {
    val processedData = remember(data) {
        // dataが変更されたときのみ再計算
        data.sortedByDescending { it.publishedAt }
            .take(10)
    }
    
    // processedDataを使用
}

// derivedStateOfで派生状態を効率的に管理
@Composable
fun NewsSearchScreen(viewModel: NewsSearchViewModel) {
    val searchQuery by viewModel.searchQuery.collectAsState()
    val allArticles by viewModel.articles.collectAsState()
    
    val filteredArticles by remember {
        derivedStateOf {
            if (searchQuery.isEmpty()) {
                allArticles
            } else {
                allArticles.filter { article ->
                    article.title.contains(searchQuery, ignoreCase = true)
                }
            }
        }
    }
}
```

## 依存性注入規約

### Koinの使用（小〜中規模プロジェクト推奨）

```kotlin
// commonMain/kotlin/di/AppModule.kt
fun appModule() = module {
    // Singleton - アプリケーション全体で1インスタンス
    single<HttpClient> {
        HttpClient(CIO) {
            install(ContentNegotiation) {
                json(Json {
                    ignoreUnknownKeys = true
                    isLenient = true
                })
            }
        }
    }
    
    single<NewsRemoteDataSource> {
        NewsRemoteDataSource(get())
    }
    
    single<NewsLocalDataSource> {
        NewsLocalDataSource()
    }
    
    single<NewsRepository> {
        NewsRepositoryImpl(
            remoteDataSource = get(),
            localDataSource = get()
        )
    }
    
    // Factory - 呼び出しごとに新しいインスタンス
    factory<NewsListViewModel> {
        NewsListViewModel(repository = get())
    }
    
    factory<NewsDetailViewModel> { params ->
        NewsDetailViewModel(
            repository = get(),
            articleId = params.get()
        )
    }
}
```

### commonMainでのモジュール定義

```kotlin
// commonMain/kotlin/di/Modules.kt
val dataModule = module {
    single<NewsRepository> { NewsRepositoryImpl(get(), get()) }
    single<TranslationService> { TranslationServiceImpl() }
}

val domainModule = module {
    factory { GetNewsListUseCase(get()) }
    factory { GetNewsDetailUseCase(get()) }
    factory { TranslateArticleUseCase(get()) }
}

val presentationModule = module {
    factory { NewsListViewModel(get()) }
    factory { params -> NewsDetailViewModel(get(), params.get()) }
}

// すべてのモジュールをまとめる
fun allModules() = listOf(
    dataModule,
    domainModule,
    presentationModule
)
```

### ViewModelの注入パターン

```kotlin
// Compose内でのViewModel取得
@Composable
fun NewsListScreen() {
    val viewModel: NewsListViewModel = koinViewModel()
    // または引数付き
    val detailViewModel: NewsDetailViewModel = koinViewModel { 
        parametersOf(articleId) 
    }
    
    val uiState by viewModel.uiState.collectAsState()
    // UI実装
}

// テストでの注入
class NewsListViewModelTest : KoinTest {
    
    @get:Rule
    val koinTestRule = KoinTestRule.create {
        modules(
            module {
                single<NewsRepository> { mockk<NewsRepository>() }
            }
        )
    }
    
    @Test
    fun testLoadNews() {
        val repository: NewsRepository by inject()
        val viewModel = NewsListViewModel(repository)
        // テスト実装
    }
}
```

## テスト規約

### 共通テスト（commonTest）の範囲

```kotlin
// commonTest/kotlin/data/repository/NewsRepositoryTest.kt
class NewsRepositoryTest {
    
    private val mockRemoteDataSource = MockNewsRemoteDataSource()
    private val mockLocalDataSource = MockNewsLocalDataSource()
    private val repository = NewsRepositoryImpl(
        mockRemoteDataSource,
        mockLocalDataSource
    )
    
    @Test
    fun `should return cached data when not expired`() = runTest {
        // Given
        val cachedArticles = listOf(createSampleArticle())
        mockLocalDataSource.saveNewsList(cachedArticles)
        
        // When
        val result = repository.getNewsList()
        
        // Then
        assertTrue(result.isSuccess)
        assertEquals(cachedArticles, result.getOrNull())
        assertFalse(mockRemoteDataSource.wasCalled)
    }
    
    @Test
    fun `should fetch from remote when cache is expired`() = runTest {
        // Given
        val remoteArticles = listOf(createSampleArticle())
        mockRemoteDataSource.setResponse(remoteArticles)
        mockLocalDataSource.clear()
        
        // When
        val result = repository.getNewsList()
        
        // Then
        assertTrue(result.isSuccess)
        assertEquals(remoteArticles, result.getOrNull())
        assertTrue(mockRemoteDataSource.wasCalled)
    }
}
```

### モックとテストダブルの実装

```kotlin
// テスト用のフェイク実装
class FakeNewsRepository : NewsRepository {
    private var shouldReturnError = false
    private var articles = mutableListOf<NewsArticle>()
    
    fun setArticles(newArticles: List<NewsArticle>) {
        articles.clear()
        articles.addAll(newArticles)
    }
    
    fun setShouldReturnError(value: Boolean) {
        shouldReturnError = value
    }
    
    override suspend fun getNewsList(): Result<List<NewsArticle>> {
        return if (shouldReturnError) {
            Result.failure(Exception("Test error"))
        } else {
            Result.success(articles)
        }
    }
}

// ViewModelのテスト
class NewsListViewModelTest {
    
    @Test
    fun `should update UI state when loading news successfully`() = runTest {
        // Arrange
        val fakeRepository = FakeNewsRepository()
        val expectedArticles = listOf(
            NewsArticle("1", "Title 1", "Content 1", LocalDateTime.now(), emptyList())
        )
        fakeRepository.setArticles(expectedArticles)
        
        val viewModel = NewsListViewModel(fakeRepository)
        
        // Act
        viewModel.loadNews()
        advanceUntilIdle()
        
        // Assert
        val state = viewModel.uiState.value
        assertFalse(state.isLoading)
        assertEquals(expectedArticles, state.articles)
        assertNull(state.error)
    }
}
```

### 命名規則

```kotlin
// テストメソッドの命名規則：
// should_expectedBehavior_when_condition
// または
// methodName_condition_expectedResult

@Test
fun `should return empty list when no articles available`() { }

@Test
fun `getNewsList returns cached data when cache is valid`() { }

@Test
fun `loadNews updates UI state with error when repository fails`() { }

// テストクラスの命名
class NewsListViewModelTest  // 対象クラス名 + Test
class NewsRepositoryImplTest
class DateFormatterTest
```

## コメントとドキュメント

### KDocの記述ルール

```kotlin
/**
 * ニュース記事を表すデータクラス
 * 
 * @property id 記事の一意識別子
 * @property title 記事のタイトル
 * @property content 記事の本文
 * @property publishedAt 公開日時
 * @property imageUrls 記事に関連する画像URLのリスト
 */
data class NewsArticle(
    val id: String,
    val title: String,
    val content: String,
    val publishedAt: LocalDateTime,
    val imageUrls: List<String>
)

/**
 * ニュース記事を取得し、キャッシュ管理を行うリポジトリ
 */
interface NewsRepository {
    /**
     * ニュース記事のリストを取得する
     * 
     * @return 成功時は記事リスト、失敗時はエラーを含むResult
     * @throws NetworkException ネットワークエラーが発生した場合
     */
    suspend fun getNewsList(): Result<List<NewsArticle>>
}

/**
 * 日付を指定されたフォーマットで文字列に変換する
 * 
 * @param date 変換対象の日付
 * @param pattern フォーマットパターン（デフォルト: "yyyy年MM月dd日"）
 * @return フォーマットされた日付文字列
 * 
 * @sample
 * ```
 * val date = LocalDateTime.now()
 * val formatted = formatDate(date) // "2025年01月22日"
 * val custom = formatDate(date, "MM/dd") // "01/22"
 * ```
 */
fun formatDate(
    date: LocalDateTime,
    pattern: String = "yyyy年MM月dd日"
): String {
    // 実装
}
```

### TODOコメントの管理

```kotlin
// TODO: [優先度:高] API実装後にSampleRepositoryから切り替える
// 担当: @developer
// 期限: 2025-02-01
class NewsListViewModel(
    private val repository: NewsRepository = SampleNewsRepository() // TODO: DIで注入
) {
    // TODO: [優先度:中] エラー時のリトライ機能を実装
    fun loadNews() {
        // 実装
    }
    
    // FIXME: メモリリークの可能性あり - コルーチンのキャンセレーション確認
    private fun observeNetworkStatus() {
        // 実装
    }
}

// NOTE: このクラスは将来的にRoom実装に置き換え予定
class InMemoryCache {
    // 実装
}
```

### 複雑なロジックへのコメント

```kotlin
// ✅ 良い例：なぜそうするのかを説明
fun calculateReadingTime(content: String): Int {
    // 日本語は1文字あたりの読み取り速度が異なるため、
    // 文字種別に応じて重み付けを行う
    val japaneseCharCount = content.count { it.isJapanese() }
    val otherCharCount = content.length - japaneseCharCount
    
    // 日本語: 600文字/分、英数字: 250単語/分（約1000文字/分）として計算
    val readingTimeSeconds = (japaneseCharCount / 10.0 + otherCharCount / 16.0).toInt()
    
    // 最小値を1分とする
    return maxOf(readingTimeSeconds / 60, 1)
}

// ❌ 悪い例：コードを読めば分かることをコメント
fun calculateSum(a: Int, b: Int): Int {
    // aとbを足す
    val sum = a + b
    // 結果を返す
    return sum
}
```

## パフォーマンス最適化ガイドライン

### リスト表示の最適化

```kotlin
@Composable
fun OptimizedNewsList(articles: List<NewsArticle>) {
    LazyColumn(
        // パフォーマンス最適化設定
        state = rememberLazyListState(),
        contentPadding = PaddingValues(vertical = 8.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(
            items = articles,
            key = { it.id }, // 安定したキーでリコンポジションを最小化
            contentType = { "NewsArticle" } // コンテンツタイプでレイアウト最適化
        ) { article ->
            NewsCard(
                article = article,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}
```

### 画像読み込みの最適化

```kotlin
@Composable
fun OptimizedNewsImage(
    imageUrl: String,
    contentDescription: String?,
    modifier: Modifier = Modifier
) {
    AsyncImage(
        model = ImageRequest.Builder(LocalContext.current)
            .data(imageUrl)
            .crossfade(true)
            .memoryCacheKey(imageUrl)
            .diskCacheKey(imageUrl)
            .build(),
        contentDescription = contentDescription,
        modifier = modifier,
        contentScale = ContentScale.Crop,
        error = painterResource(Res.drawable.placeholder_error),
        placeholder = painterResource(Res.drawable.placeholder_loading)
    )
}
```

### メモリ管理

```kotlin
class NewsListViewModel : ViewModel() {
    // 大量のデータを扱う場合はページングを検討
    private val _articles = MutableStateFlow<List<NewsArticle>>(emptyList())
    
    // WeakReferenceで画像キャッシュを管理
    private val imageCache = mutableMapOf<String, WeakReference<Bitmap>>()
    
    override fun onCleared() {
        super.onCleared()
        // リソースのクリーンアップ
        imageCache.clear()
    }
}
```

## セキュリティガイドライン

### APIキーの管理

```kotlin
// ❌ 悪い例：ハードコーディング
class ApiClient {
    private val apiKey = "sk-1234567890abcdef"
}

// ✅ 良い例：環境変数から取得
class ApiClient {
    private val apiKey = getEnvironmentVariable("API_KEY")
        ?: throw IllegalStateException("API_KEY not configured")
}
```

### 機密情報のログ出力禁止

```kotlin
// ❌ 悪い例
Logger.log("User token: $userToken")

// ✅ 良い例
Logger.log("User authenticated: ${userToken.isNotEmpty()}")
```

---

このコーディング規約は継続的に更新され、プロジェクトの成長とともに進化します。
すべての開発者はこれらの規約に従い、一貫性のある保守しやすいコードを書くことが求められます。